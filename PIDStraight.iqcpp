{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor LeftMotor = motor(PORT1, false);\nmotor RightMotor = motor(PORT6, true);\n\n#pragma endregion VEXcode Generated Robot Configuration\n#include \"vex.h\"\n\nusing namespace vex;\n\nconst double WHEEL_DIAMETER = 2.5;  // Assuming wheel diameter is 2.5 inches\nconst double WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * 3.1415926535;\nconst double DEGREES_PER_INCH = 360.0 / WHEEL_CIRCUMFERENCE;\n\n// PID constants\nconst double kP = 1.0;  // Placeholder values, you need to tune these\nconst double kI = 0.1;\nconst double kD = 0.01;\n\nvoid driveStraight(double distanceInInches) {\n  double targetDistanceInDegrees = distanceInInches * DEGREES_PER_INCH;\n\n  // Your motor initialization code here (assuming LeftMotor and RightMotor)\n\n  double error, integral, derivative, lastError;\n  double power, integralLimit;\n\n  integralLimit = 10.0;  // Prevent integral windup, adjust as needed\n  integral = 0.0;\n  lastError = 0.0;\n\n  while (true) {\n    error = targetDistanceInDegrees - (LeftMotor.rotation(degrees) + RightMotor.rotation(degrees)) / 2.0;\n    \n    integral += error;\n    if (integral > integralLimit) integral = integralLimit;\n    if (integral < -integralLimit) integral = -integralLimit;\n\n    derivative = error - lastError;\n    lastError = error;\n\n    power = kP * error + kI * integral + kD * derivative;\n\n    LeftMotor.spin(forward, power, percent);\n    RightMotor.spin(forward, power, percent);\n\n    if (fabs(error) < 1.0) break;  // Adjust the threshold as needed\n\n    task::sleep(20);  // Adjust the sleep time based on your control loop speed\n  }\n\n  // Your motor stopping code here\n  LeftMotor.stop();\n  RightMotor.stop();\n}\n\nint whenStarted1() {\n  driveStraight(12.0);  // Move forward for 12 inches\n\n  return 0;\n}","textLanguage":"cpp","rconfig":[{"port":[1],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}